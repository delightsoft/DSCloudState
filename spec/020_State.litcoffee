В связи с тем, что socket.io-client может выполнять reconnect, то вместо начальной идеи, что clone создается
при подключении к origin-объекту.  И в случае пропадания связи с origin clone-объект переходит в состояние
disconnected, и всё.  Мы переходим к варианту, когда clone-объект создается и пытается подключиться к origin, при
подключении у него меняется состояние.  И соотвественно в случае reconnect он переходит в состояние reconnecting,
что означает что он может в любой момент снова обновить своё состояние.

Основная проблема при reconnect, это то что мы должны понимать пропустили ли мы какие нибудь события.  При быстром
reconnect мы можем передать пропущенные изменнеия, если они у нас некоторое время хранятся в дополнительной очереди.

При длительном reconnect скорее всего потребуется передать полное состояние.  Очевидно, что передача полного состояния
становится таким же обновлением как и все другие, и происходит при начально подключении и после длительного reconnect.

Чтоб понимать, сколько событий было пропущено при reconnect мы должны добавить revision к состоянию, чтоб он
увеличивался на единицы при каждом обновлении.  Если передавать revision вместе с обновлениями, то можно его
использовать так же для контроля качества работы socket.io - не случаются ли пропуски состояния.

Статусы clone-объекта, те же что будут в новой версии JSApp для DSSet:
- $ds_ready - true, есть загруженные данные
- $ds_loading - true, если данные загружаются

У origin-объекта всегда статус $ds_ready = true и $ds_loading = false, так как ему не важно подключается к нему clone-объекты или нет.  А статус ему нужен, чтоб
по интерфейсу не отличаться от clone-объектов.